<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Sigilo 3D - Game.glb</title>
  <style>
    body { margin:0; overflow:hidden; background:#111; font-family: Arial, sans-serif; }
    canvas { display:block; width:100vw; height:100vh; }
    .hud{
      position:absolute; left:10px; top:10px; z-index:2;
      color:#ddd; background:rgba(0,0,0,.45);
      padding:10px 12px; border-radius:10px; font-size:14px;
      pointer-events:none;
      line-height: 1.35;
      max-width: 640px;
    }
    .hud b{color:#fff;}

    /* ===== DIALOGO SOBRE LA CABEZA (terminal) ===== */
    #speech{
      position: fixed;
      z-index: 9998;
      pointer-events: none;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(0,0,0,0.70);
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      font-size: 14px;
      line-height: 1.2;
      max-width: 340px;
      transform: translate(-50%, -100%);
      white-space: pre-wrap;

      /* ‚Äúterminal‚Äù sin descargar */
      font-family: ui-monospace, "Cascadia Mono", Consolas, Menlo, Monaco, "Courier New", monospace;
      text-shadow: 0 1px 0 rgba(0,0,0,0.8);
    }

    /* ===== OVERLAYS ===== */
    .overlay{
      position: fixed; inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      background: rgba(0,0,0,0.70);
    }
    .overlay .card{
      background: rgba(10,10,10,0.85);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 18px 20px;
      min-width: 320px;
      text-align: center;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      color: #fff;
    }
    .overlay .title{
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.3px;
      margin-bottom: 12px;
    }
    .overlay button{
      pointer-events: auto;
      cursor: pointer;
      border: 0;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 700;
      background: #ffffff;
      color: #111;
    }
    .overlay button:hover{ opacity: 0.92; }
  </style>
</head>
<body>
  <div class="hud">
    <div><b>WASD</b> mover</div>
    <div><b>Mouse</b> rueda zoom ¬∑ izq rotar ¬∑ der pan</div>
    <div><b>C</b> recentrar c√°mara</div>
    <div id="status">Cargando Game.glb...</div>
    <div id="debug"></div>
  </div>

  <!-- Dialogo (sobre la cabeza) -->
  <div id="speech" style="display:none"></div>

  <!-- ===== WIN UI ===== -->
  <div id="winOverlay" class="overlay">
    <div class="card">
      <div class="title">¬°GANASTE! LOGRASTE ESCAPAR.</div>
      <button id="retryBtnWin">Retry</button>
    </div>
  </div>

  <!-- ===== LOSE UI ===== -->
  <div id="loseOverlay" class="overlay">
    <div class="card">
      <div class="title">¬°PERDISTE!</div>
      <button id="retryBtnLose">Retry</button>
    </div>
  </div>

  <script src="./libs/three.min.js"></script>
  <script src="./libs/GLTFLoader.js"></script>
  <script src="./libs/OrbitControls.js"></script>


  <script>
    let scene, camera, renderer, clock, controls;
    let root, suelo, playerRig, bossRig;
    let playerMixer, bossMixer;
    let playerAnims = {}, bossAnims = {};
    let playerCurrent = null, bossCurrent = null;

    const statusEl = document.getElementById("status");
    const debugEl  = document.getElementById("debug");
    function setStatus(t){ statusEl.textContent = t; }
    function setDebug(t){ debugEl.textContent = t; }

    const keys = { w:false, a:false, s:false, d:false };

    // ===== AUDIO AMBIENTE (EN ORDEN) + CROSSFADE (FADE IN/OUT) =====
    // Patch: timers por-audio (para que fade in/out no se pisen) + scheduling robusto + archivos en MAY√öSCULAS
    let ambA = null, ambB = null;
    let ambActive = null;      // el que suena ahora
    let ambInactive = null;    // el que se prepara para el pr√≥ximo
    let audioStarted = false;

    const playlist = [
      { src: "AMBIENTE1.mp3", vol: 1.00 },
      { src: "AMBIENTE2.mp3", vol: 0.75 },
      { src: "AMBIENTE3.mp3", vol: 0.50 },
    ];

    let trackIndex = 0;

    // Ajustes
    const FADE_IN_S    = 1.20;
    const FADE_OUT_S   = 1.20;
    const XFADE_S      = 1.20;
    const FADE_STEP_MS = 30;

    let nextXFadeTimeout = null;

    function clearXFadeTimeout(){
      if (nextXFadeTimeout) { clearTimeout(nextXFadeTimeout); nextXFadeTimeout = null; }
    }

    // ‚úÖ timer por-audio (no global)
    function clearAudioFadeTimer(audioEl){
      if (!audioEl) return;
      if (audioEl._fadeTimer) {
        clearInterval(audioEl._fadeTimer);
        audioEl._fadeTimer = null;
      }
    }

    function initAudio(){
      ambA = new Audio();
      ambB = new Audio();

      for (const a of [ambA, ambB]){
        a.preload = "auto";
        a.loop = false;
        a._fadeTimer = null;
      }

      ambActive = ambA;
      ambInactive = ambB;
    }

    function fadeAudioTo(audioEl, targetVol, seconds, onDone){
      if (!audioEl) return;
      clearAudioFadeTimer(audioEl);

      const startVol = (typeof audioEl.volume === "number") ? audioEl.volume : 0;
      const delta = targetVol - startVol;
      const steps = Math.max(1, Math.floor((seconds * 1000) / FADE_STEP_MS));
      let i = 0;

      audioEl._fadeTimer = setInterval(() => {
        i++;
        const t = i / steps;
        audioEl.volume = Math.max(0, Math.min(1, startVol + delta * t));

        if (i >= steps){
          clearAudioFadeTimer(audioEl);
          audioEl.volume = Math.max(0, Math.min(1, targetVol));
          if (onDone) onDone();
        }
      }, FADE_STEP_MS);
    }

    function scheduleNextCrossfade(){
      if (!ambActive) return;

      clearXFadeTimeout();

      // Limpia handler viejo
      ambActive.onended = null;

      const arm = () => {
        const dur = ambActive.duration;

        if (!Number.isFinite(dur) || dur <= 0){
          // Espera metadata de forma robusta
          ambActive.onloadedmetadata = arm;
          ambActive.ondurationchange = arm;
          return;
        }

        // ya tenemos duraci√≥n: armamos el crossfade
        ambActive.onloadedmetadata = null;
        ambActive.ondurationchange = null;

        const ms = Math.max(0, (dur - XFADE_S) * 1000);

        nextXFadeTimeout = setTimeout(() => {
          if (!audioStarted) return;
          if (!ambActive || ambActive.paused) return;

          trackIndex = (trackIndex + 1) % playlist.length;
          playTrack(trackIndex);
        }, ms);
      };

      arm();

      // Fallback final (si termina igual)
      ambActive.onended = () => {
        if (!audioStarted) return;
        trackIndex = (trackIndex + 1) % playlist.length;
        playTrack(trackIndex);
      };
    }

    function playTrack(i){
      if (!ambActive || !ambInactive) return;

      const next = playlist[i];

      // prepara el siguiente audio
      ambInactive.src = next.src;
      ambInactive.currentTime = 0;
      ambInactive.volume = 0;

      ambInactive.play().catch(()=>{});

      // fades simult√°neos sin pisarse
      fadeAudioTo(ambInactive, next.vol, FADE_IN_S);

      const prev = ambActive;
      fadeAudioTo(prev, 0, FADE_OUT_S, () => {
        try { prev.pause(); } catch(e){}
        prev.currentTime = 0;
      });

      // swap
      const tmp = ambActive;
      ambActive = ambInactive;
      ambInactive = tmp;

      scheduleNextCrossfade();
    }

    function startAudioOnce(){
      if (audioStarted) return;
      audioStarted = true;
      trackIndex = 0;

      if (!ambActive) initAudio();

      const first = playlist[trackIndex];
      ambActive.src = first.src;
      ambActive.currentTime = 0;
      ambActive.volume = 0;

      ambActive.play().catch(()=>{});
      fadeAudioTo(ambActive, first.vol, FADE_IN_S);

      scheduleNextCrossfade();
    }

    function pauseAudio(){
      if (!ambActive) return;

      clearXFadeTimeout();

      // apaga ambos por si justo estaba crossfadeando
      const a1 = ambActive;
      const a2 = ambInactive;

      fadeAudioTo(a1, 0, 0.6, () => { try { a1.pause(); } catch(e){} });
      if (a2 && !a2.paused) {
        fadeAudioTo(a2, 0, 0.6, () => { try { a2.pause(); } catch(e){} });
      }
    }

    function resumeAudio(){
      if (!ambActive) return;
      if (!audioStarted) return;

      ambActive.play().catch(()=>{});
      const t = playlist[trackIndex];
      fadeAudioTo(ambActive, t.vol, 0.6);

      // por seguridad, apaga el inactivo si qued√≥ vivo
      if (ambInactive && !ambInactive.paused) {
        fadeAudioTo(ambInactive, 0, 0.4, () => { try { ambInactive.pause(); } catch(e){} });
      }

      scheduleNextCrossfade();
    }

    // ===== DIALOGO SOBRE LA CABEZA (HTML overlay) =====
    const speechEl = document.getElementById("speech");
    let speechUntil = 0;
    const _headPos = new THREE.Vector3();

    function say(text, seconds = 2.6){
      speechEl.textContent = text;
      speechUntil = performance.now() + seconds * 1000;
      speechEl.style.display = "block";
    }

    function updateSpeech(){
      if (!playerRig || !speechEl) return;

      if (speechEl.style.display !== "none" && performance.now() > speechUntil){
        speechEl.style.display = "none";
        return;
      }
      if (speechEl.style.display === "none") return;

      // cabeza aproximada
      playerRig.getWorldPosition(_headPos);
      _headPos.y += 1.6;

      const p = _headPos.clone().project(camera);
      const x = (p.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-p.y * 0.5 + 0.5) * window.innerHeight;

      speechEl.style.left = `${x}px`;
      speechEl.style.top  = `${y}px`;
    }

    // ===== GAME STATE =====
    let seen = false;

    // ===== WIN/LOSE STATE =====
    let gameWon = false;
    let gameLost = false;
    const winOverlay = document.getElementById("winOverlay");
    const loseOverlay = document.getElementById("loseOverlay");
    document.getElementById("retryBtnWin").addEventListener("click", resetGame);
    document.getElementById("retryBtnLose").addEventListener("click", resetGame);

    // ===== TIMER (1 min) =====
    const ROUND_TIME_MS = 60000;
    let timeLeftMs = ROUND_TIME_MS;

    function formatTime(ms){
      ms = Math.max(0, ms);
      const total = Math.ceil(ms / 1000);
      const m = Math.floor(total / 60);
      const s = total % 60;
      return `${m}:${String(s).padStart(2,"0")}`;
    }

    // ===== WAYPOINTS (WP_000..WP_012) =====
    let waypoints = [];
    let wpIndex = 0;
    const BOSS_SPEED = 1.4;
    const WP_EPS = 0.25;
    const _bossToWP = new THREE.Vector3();

    // ===== COLISIONES (XZ) =====
    let PLAYER_RADIUS = 0.20;
    let BOSS_RADIUS   = 0.01;
    let obstacles = [];

    // ===== DEBUG VISUAL (cajas verdes) =====
    const SHOW_OBS_HELPERS = true;
    const MAX_HELPERS = 36;
    let obstacleHelpers = [];

    // ===== AJUSTE DE BOXES (desde centro) =====
    const BOX_SCALE = { x: 0.78, z: 1.00 };

    // ===== FOV (visible) =====
    let bossHeadBone = null;
    let fovMesh = null;
    const FOV = {
      dist: 7.5,
      angleDeg: 32,
      y: 0.03,
      color: 0xff4444,
      opacity: 0.22,
      opacitySeen: 0.48,
      headYOffset: 1.6
    };

    // ===== M√ÅSCARAS (pickups) =====
    let maskKitsune = null;
    let maskOni = null;
    let maskChane = null;
    const PICKUP_RADIUS = 0.35;

    const powers = {
      kitsune: false,
      oni: false,
      chane: false,
      invisUntil: 0
    };

    const extraKeys = { e:false, space:false };

    // fuego
    const projectiles = [];
    const FIRE = { speed: 9.0, life: 1.2, cooldownMs: 250, lastShot: 0 };
    const BOSS = { hp: 100, alive: true };

    // ===== PORTAL =====
    let portalMesh = null;
    let portalMat = null;

    function createPortal(){
      const geom = new THREE.PlaneGeometry(1, 1, 64, 64);

      portalMat = new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        uniforms: { time: { value: 0 } },
        vertexShader: `
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform float time;
          void main(){
            vec2 uv = vUv - 0.5;
            uv.x *= 0.6;
            float d = length(uv);
            float wave = sin(d * 20.0 - time * 4.0) * 0.03;
            float mask = smoothstep(0.45 + wave, 0.35, d);
            vec3 col = mix(vec3(0.1, 0.4, 1.0), vec3(0.6, 0.9, 1.0), 1.0 - d * 2.0);
            gl_FragColor = vec4(col, mask);
          }
        `
      });

      portalMesh = new THREE.Mesh(geom, portalMat);
      portalMesh.position.set(-15, 0.8, -5);
      portalMesh.scale.set(0.8, 2, 1);
      portalMesh.rotation.y = Math.PI;
      scene.add(portalMesh);
    }

    // ===== FOV yaw robusto (world) =====
    const _tmp = new THREE.Vector3();
    const _q = new THREE.Quaternion();
    const _fwd = new THREE.Vector3(0, 0, 1);
    function getBossYawWorld(obj){
      obj.getWorldQuaternion(_q);
      const v = _fwd.clone().applyQuaternion(_q);
      return Math.atan2(v.x, v.z);
    }

    function isInvisible(){
      return powers.kitsune && performance.now() < powers.invisUntil;
    }

    // ===== b√∫squeda flexible de meshes por nombre =====
    function findByNameLoose(rootObj, needle){
      const target = (needle || "").toLowerCase();
      let found = null;
      rootObj.traverse((o) => {
        if (found || !o.name) return;
        const n = o.name.toLowerCase();
        if (n === target || n.includes(target)) found = o;
      });
      return found;
    }

    // ===== radio de pickup basado en tama√±o real del mesh =====
    function getPickupRadiusFor(mesh){
      if (!mesh || !mesh.geometry) return PICKUP_RADIUS;
      const g = mesh.geometry;
      if (!g.boundingSphere) g.computeBoundingSphere();
      const r = g.boundingSphere ? g.boundingSphere.radius : 0;

      const s = new THREE.Vector3();
      mesh.getWorldScale(s);
      const worldR = r * Math.max(s.x, s.z);
      return Math.max(PICKUP_RADIUS, worldR * 0.8);
    }

    // ===== DETECCI√ìN (FOV rojo como verdad) =====
    const _playerPos = new THREE.Vector3();
    const _toPlayer = new THREE.Vector3();
    const _fovForward = new THREE.Vector3();
    function isPlayerInFOV(){
      if (isInvisible()) return false;
      if (!playerRig || !bossRig || !fovMesh) return false;

      const origin = fovMesh.position;
      playerRig.getWorldPosition(_playerPos);

      _toPlayer.set(_playerPos.x - origin.x, 0, _playerPos.z - origin.z);
      const dist = _toPlayer.length();
      if (dist > FOV.dist) return false;
      if (dist < 0.0001) return true;
      _toPlayer.normalize();

      _fovForward.set(1, 0, 0).applyQuaternion(fovMesh.quaternion);
      _fovForward.y = 0;
      _fovForward.normalize();

      const dot = THREE.Math.clamp(_fovForward.dot(_toPlayer), -1, 1);
      const angle = Math.acos(dot);
      const half = THREE.Math.degToRad(FOV.angleDeg) / 2;

      if (isLineBlockedXZ(fovMesh.position, _playerPos)) return false;
      return angle <= half;
    }

    // ===== C√ÅMARA =====
    const CAM = {
      minDist: 6,
      maxDist: 10,
      minPolar: 0.30,
      maxPolar: 0.60,
      minAzimuth: -0.55,
      maxAzimuth:  0.55,
      maxTargetOffset: 1.5,
      targetHeight: 0.2
    };
    let followPlayer = true;

    // ===== ANIMS helpers =====
    function fadeTo(current, next){
      if (!next || current === next) return current;
      if (current) current.fadeOut(0.15);
      next.reset().fadeIn(0.15).play();
      return next;
    }
    function playPlayer(name){
      const next = playerAnims[name];
      if (!next) return;
      playerCurrent = fadeTo(playerCurrent, next);
    }
    function playBoss(name){
      const next = bossAnims[name];
      if (!next) return;
      bossCurrent = fadeTo(bossCurrent, next);
    }

    // ===== WIN/LOSE helpers =====
    function hasAllMasks(){ return powers.kitsune && powers.oni && powers.chane; }

    function checkPortalWin(){
      if (!portalMesh || !playerRig) return false;
      if (!hasAllMasks()) return false;

      const p = new THREE.Vector3();
      const e = new THREE.Vector3();
      playerRig.getWorldPosition(p);
      portalMesh.getWorldPosition(e);

      const dx = p.x - e.x;
      const dz = p.z - e.z;

      return (dx*dx + dz*dz) <= (0.9 * 0.9);
    }

    function winGame(){
      gameWon = true;
      winOverlay.style.display = "flex";
      pauseAudio();
    }

    function loseGame(){
      gameLost = true;
      loseOverlay.style.display = "flex";
      pauseAudio();
    }

    function resetGame(){
      // UI
      winOverlay.style.display = "none";
      loseOverlay.style.display = "none";
      gameWon = false;
      gameLost = false;

      // timer
      timeLeftMs = ROUND_TIME_MS;

      // states
      seen = false;
      powers.kitsune = false;
      powers.oni = false;
      powers.chane = false;
      powers.invisUntil = 0;

      FIRE.lastShot = 0;
      BOSS.hp = 100;
      BOSS.alive = true;

      // speech reset
      speechEl.style.display = "none";
      speechUntil = 0;

      // masks back
      if (maskKitsune) maskKitsune.visible = true;
      if (maskOni) maskOni.visible = true;
      if (maskChane) maskChane.visible = true;

      // clear projectiles
      for (let i = projectiles.length - 1; i >= 0; i--){
        scene.remove(projectiles[i].mesh);
        projectiles.splice(i,1);
      }

      // reset positions
      if (playerRig) playerRig.position.set(10, 0, 0);
      if (bossRig) bossRig.position.set(6, 0, 0);
      wpIndex = 0;

      // reset portal anim
      if (portalMat) portalMat.uniforms.time.value = 0;
      if (fovMesh) fovMesh.material.opacity = FOV.opacity;

      setStatus("Retry...");

      // audio
      resumeAudio();
    }

    function loseByTime(){
      timeLeftMs = 0;
      setStatus("¬°PERDISTE!");
      loseGame();
    }

    function clampTargetToPlayer(){
      if (!playerRig) return;
      const p = playerRig.position;
      const desired = new THREE.Vector3(p.x, p.y + CAM.targetHeight, p.z);

      const offset = controls.target.clone().sub(desired);
      offset.y = 0;

      const max = CAM.maxTargetOffset;
      if (offset.length() > max) offset.setLength(max);

      controls.target.set(desired.x + offset.x, desired.y, desired.z + offset.z);
    }

    // ===== FOV mesh helpers =====
    function findHeadBone(obj){
      let found = null;
      obj.traverse((n) => {
        if (found) return;
        if (n && n.isBone && typeof n.name === "string") {
          const s = n.name.toLowerCase();
          if (s.includes("head") || s.includes("cabeza")) found = n;
        }
      });
      return found;
    }

    function createFOVMesh(){
      const r = FOV.dist;
      const a = THREE.Math.degToRad(FOV.angleDeg);
      const half = a / 2;

      const shape = new THREE.Shape();
      shape.moveTo(0, 0);
      shape.absarc(0, 0, r, -half, +half, false);
      shape.lineTo(0, 0);

      const geom = new THREE.ShapeGeometry(shape, 32);
      const mat = new THREE.MeshBasicMaterial({
        color: FOV.color,
        transparent: true,
        opacity: FOV.opacity,
        depthWrite: false,
        side: THREE.DoubleSide
      });

      const mesh = new THREE.Mesh(geom, mat);
      mesh.rotation.order = "YXZ";
      mesh.rotation.set(-Math.PI / 2, 0, 0);
      scene.add(mesh);
      return mesh;
    }

    function updateFOV(){
      if (!bossRig || !fovMesh) return;

      if (bossHeadBone) bossHeadBone.getWorldPosition(_tmp);
      else {
        bossRig.getWorldPosition(_tmp);
        _tmp.y += FOV.headYOffset;
      }

      fovMesh.position.set(_tmp.x, FOV.y, _tmp.z);

      const yaw = bossRig.rotation.y;
      fovMesh.rotation.set(-Math.PI / 2, yaw - Math.PI/2, 0);
    }

    // ===== COLLISION helpers =====
    function resizeBoxFromCenter(box, scaleX, scaleZ){
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      const OFFSET_X = 0;
      const OFFSET_Z = 0;
      center.x += OFFSET_X;
      center.z += OFFSET_Z;

      size.x *= 1;
      size.z *= 1;

      box.min.set(center.x - size.x/2, box.min.y, center.z - size.z/2);
      box.max.set(center.x + size.x/2, box.max.y, center.z + size.z/2);
    }

    function clearObstacleHelpers(){
      for (const h of obstacleHelpers) scene.remove(h);
      obstacleHelpers.length = 0;
    }

    function addBoxHelperFromObstacle(o, colorHex){
      const box = new THREE.Box3(
        new THREE.Vector3(o.minX, 0, o.minZ),
        new THREE.Vector3(o.maxX, 0, o.maxZ)
      );
      box.min.y = 0;
      box.max.y = 2.0;

      const helper = new THREE.Box3Helper(box, colorHex);
      obstacleHelpers.push(helper);
      scene.add(helper);
    }

    function buildObstaclesFromCubes(rootObj){
      const nodes = [];
      const byUuid = new Set();

      rootObj.updateMatrixWorld(true);

      rootObj.traverse((o) => {
        if (!o || !o.name || !o.name.startsWith("Cube")) return;
        if (byUuid.has(o.uuid)) return;
        byUuid.add(o.uuid);
        nodes.push(o);
      });

      for (let i = 0; i <= 35; i++){
        const name = (i === 0) ? "Cube" : `Cube.${String(i).padStart(3,"0")}`;
        const o = rootObj.getObjectByName(name);
        if (!o) continue;
        if (byUuid.has(o.uuid)) continue;
        byUuid.add(o.uuid);
        nodes.push(o);
      }

      const list = [];
      const box = new THREE.Box3();

      for (const o of nodes){
        o.updateMatrixWorld(true);
        box.setFromObject(o);
        resizeBoxFromCenter(box, BOX_SCALE.x, BOX_SCALE.z);

        list.push({
          name: o.name,
          minX: box.min.x, maxX: box.max.x,
          minZ: box.min.z, maxZ: box.max.z
        });
      }

      list.sort((a,b) => a.name.localeCompare(b.name));

      if (SHOW_OBS_HELPERS) {
        clearObstacleHelpers();
        const n = Math.min(list.length, MAX_HELPERS);
        for (let i = 0; i < n; i++){
          addBoxHelperFromObstacle(list[i], 0x00ff00);
        }
      }

      return list;
    }

    function resolveCircleVsAABB(pos, radius){
      for (let iter = 0; iter < 3; iter++){
        for (let i = 0; i < obstacles.length; i++){
          const o = obstacles[i];

          const cx = THREE.Math.clamp(pos.x, o.minX, o.maxX);
          const cz = THREE.Math.clamp(pos.z, o.minZ, o.maxZ);

          const dx = pos.x - cx;
          const dz = pos.z - cz;
          const d2 = dx*dx + dz*dz;

          if (d2 > radius*radius) continue;

          const left   = Math.abs(pos.x - o.minX);
          const right  = Math.abs(o.maxX - pos.x);
          const down   = Math.abs(pos.z - o.minZ);
          const up     = Math.abs(o.maxZ - pos.z);

          const m = Math.min(left, right, down, up);

          if (m === left)       pos.x = o.minX - radius;
          else if (m === right) pos.x = o.maxX + radius;
          else if (m === down)  pos.z = o.minZ - radius;
          else                  pos.z = o.maxZ + radius;
        }
      }
    }

    // ===== LOS (XZ): segmento vs AABB =====
    function segmentIntersectsAABB2D(x0, z0, x1, z1, b){
      let t0 = 0, t1 = 1;
      const dx = x1 - x0;
      const dz = z1 - z0;

      function clip(p, q){
        if (p === 0) return q >= 0;
        const r = q / p;
        if (p < 0) { if (r > t1) return false; if (r > t0) t0 = r; }
        else       { if (r < t0) return false; if (r < t1) t1 = r; }
        return true;
      }

      if (!clip(-dx, x0 - b.minX)) return false;
      if (!clip( dx, b.maxX - x0)) return false;
      if (!clip(-dz, z0 - b.minZ)) return false;
      if (!clip( dz, b.maxZ - z0)) return false;

      return true;
    }

    function isLineBlockedXZ(from, to){
      const x0 = from.x, z0 = from.z;
      const x1 = to.x,   z1 = to.z;

      for (let i = 0; i < obstacles.length; i++){
        const b = obstacles[i];

        const inside =
          x0 >= b.minX && x0 <= b.maxX &&
          z0 >= b.minZ && z0 <= b.maxZ;
        if (inside) continue;

        if (segmentIntersectsAABB2D(x0, z0, x1, z1, b)) return true;
      }
      return false;
    }

    // ===== WAYPOINTS =====
    function collectWaypoints(rootObj){
      const list = [];
      rootObj.updateMatrixWorld(true);

      rootObj.traverse((o) => {
        if (!o || typeof o.name !== "string" || !o.name.startsWith("WP_")) return;
        const p = new THREE.Vector3();
        o.getWorldPosition(p);
        list.push({ name: o.name, pos: p });
      });

      list.sort((a,b) => a.name.localeCompare(b.name));
      return list.map(w => w.pos);
    }

    function updateBossPatrol(dt){
      if (!bossRig || seen || !BOSS.alive) return;

      if (!waypoints.length) {
        bossRig.position.x += 1.4 * dt;
        return;
      }

      const target = waypoints[wpIndex];
      _bossToWP.set(target.x - bossRig.position.x, 0, target.z - bossRig.position.z);

      const dist = _bossToWP.length();
      if (dist < WP_EPS) {
        wpIndex = (wpIndex + 1) % waypoints.length;
        return;
      }

      _bossToWP.normalize();
      bossRig.position.x += _bossToWP.x * BOSS_SPEED * dt;
      bossRig.position.z += _bossToWP.z * BOSS_SPEED * dt;

      bossRig.rotation.y = Math.atan2(_bossToWP.x, _bossToWP.z);

      if (obstacles.length) resolveCircleVsAABB(bossRig.position, BOSS_RADIUS);
    }

    // ===== MASKS / POWERS =====
    function updatePickups(){
      if (!playerRig) return;

      const p = new THREE.Vector3();
      playerRig.getWorldPosition(p);

      function tryPick(mesh, keyName){
        if (!mesh || !mesh.visible) return false;

        const m = new THREE.Vector3();
        mesh.getWorldPosition(m);

        const dx = p.x - m.x;
        const dz = p.z - m.z;

        const r = getPickupRadiusFor(mesh);
        const d2 = dx*dx + dz*dz;

        if (d2 <= r*r) {
          mesh.visible = false;
          powers[keyName] = true;

          // di√°logo seg√∫n m√°scara
          if (keyName === "oni") {
            say("Se te acaba de pudrir el queso, ortiva.", 2.6);
          } else if (keyName === "kitsune") {
            say("No existo. Nunca estuve ac√°.", 2.6);
          } else if (keyName === "chane") {
            say("Un gran poder conlleva una gran velocidad. O algo as√≠.", 3.0);
          }

          return true;
        }
        return false;
      }

      let got = false;
      got = tryPick(maskKitsune, "kitsune") || got;
      got = tryPick(maskOni, "oni") || got;
      got = tryPick(maskChane, "chane") || got;

      if (got) setStatus("üé≠ M√°scara obtenida");
    }

    function useKitsune(){
      if (!powers.kitsune) return;
      powers.invisUntil = performance.now() + 5000;
    }

    function shootFireball(){
      if (!powers.oni || !playerRig) return;

      const now = performance.now();
      if (now - FIRE.lastShot < FIRE.cooldownMs) return;
      FIRE.lastShot = now;

      const yaw = playerRig.rotation.y;
      const dir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();

      const pos = new THREE.Vector3();
      playerRig.getWorldPosition(pos);
      pos.add(dir.clone().multiplyScalar(0.35));
      pos.y = 0.15;

      const geom = new THREE.SphereGeometry(0.06, 10, 10);
      const mat  = new THREE.MeshStandardMaterial({ color: 0xff7a3d, emissive: 0x331000, emissiveIntensity: 0.6 });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(pos);
      scene.add(mesh);

      projectiles.push({ mesh, vel: dir.multiplyScalar(FIRE.speed), life: FIRE.life });
    }

    function updateProjectiles(dt){
      if (!projectiles.length) return;

      for (let i = projectiles.length - 1; i >= 0; i--){
        const pr = projectiles[i];
        pr.life -= dt;
        pr.mesh.position.x += pr.vel.x * dt;
        pr.mesh.position.z += pr.vel.z * dt;

        if (bossRig && BOSS.alive) {
          const b = new THREE.Vector3();
          bossRig.getWorldPosition(b);
          const dx = pr.mesh.position.x - b.x;
          const dz = pr.mesh.position.z - b.z;
          if ((dx*dx + dz*dz) <= (0.35*0.35)) {
            BOSS.hp -= 20;
            scene.remove(pr.mesh);
            projectiles.splice(i,1);

            if (BOSS.hp <= 0) BOSS.alive = false;
            continue;
          }
        }

        if (pr.life <= 0) {
          scene.remove(pr.mesh);
          projectiles.splice(i,1);
        }
      }
    }

    function updateHUD(){
      const maskCount = (powers.kitsune?1:0) + (powers.oni?1:0) + (powers.chane?1:0);
      const invis = isInvisible() ? ` | Invis ${(Math.max(0, (powers.invisUntil - performance.now())/1000)).toFixed(1)}s` : "";
      const boss = BOSS.alive ? ` | BossHP ${BOSS.hp}` : " | Boss OFF";
      const t = ` | Tiempo ${formatTime(timeLeftMs)}`;
      setDebug(`M√°scaras ${maskCount}/3${invis}${boss}${t}`);
    }

    function loadGLB(){
      const loader = new THREE.GLTFLoader();
      loader.load("Game.glb", (gltf) => {
        setStatus("‚úÖ GLB cargado. Buscando objetos...");

        root = gltf.scene;
        scene.add(root);

        suelo = root.getObjectByName("Suelo");
        playerRig = root.getObjectByName("Armature");
        bossRig = root.getObjectByName("riggvigilante");

        maskKitsune = findByNameLoose(root, "kitsune");
        maskOni     = findByNameLoose(root, "oni");
        maskChane   = findByNameLoose(root, "chane");

        obstacles = buildObstaclesFromCubes(root);
        waypoints = collectWaypoints(root);
        wpIndex = 0;

        setStatus(`‚úÖ Cubos: ${obstacles.length} | Waypoints: ${waypoints.length}`);
        setDebug(`Tiempo ${formatTime(timeLeftMs)}`);

        if (playerRig) playerRig.position.set(10, 0, 0);
        if (bossRig) bossRig.position.set(6, 0, 0);

        if (playerRig) {
          playerMixer = new THREE.AnimationMixer(playerRig);
          gltf.animations.forEach((clip) => {
            if (clip.name === "idle1" || clip.name === "run1") {
              playerAnims[clip.name] = playerMixer.clipAction(clip);
            }
          });
          playPlayer("idle1");
        }

        if (bossRig) {
          bossMixer = new THREE.AnimationMixer(bossRig);
          gltf.animations.forEach((clip) => {
            if (clip.name === "idle2" || clip.name === "walk2") {
              bossAnims[clip.name] = bossMixer.clipAction(clip);
            }
          });
          playBoss(bossAnims["walk2"] ? "walk2" : "idle2");

          bossHeadBone = findHeadBone(bossRig);
          fovMesh = createFOVMesh();
          updateFOV();
        }

        if (playerRig) {
          const p = playerRig.position;
          controls.target.set(p.x, p.y + CAM.targetHeight, p.z);
          camera.position.set(p.x + 0.01, p.y + 12, p.z + 6);
          controls.update();
        }
      }, undefined, (err) => {
        console.error("Error cargando Game.glb:", err);
        setStatus("‚ùå Error cargando Game.glb (mir√° consola).");
      });
    }

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
      camera.position.set(0, 12, 8);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const hemi = new THREE.HemisphereLight(0xffffff, 0x333333, 1.0);
      hemi.position.set(0, 50, 0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 1.2);
      dir.position.set(15, 25, 10);
      scene.add(dir);

      const spot = new THREE.SpotLight(0xffffff, 11.6);
      spot.position.set(0, 5, 11);
      spot.angle = Math.PI / 8;
      spot.penumbra = 0.4;
      spot.decay = 2;
      spot.distance = 25;
      spot.target.position.set(0, 0, 11);
      scene.add(spot);
      scene.add(spot.target);

      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.8;

      scene.add(new THREE.GridHelper(80, 80, 0x666666, 0x333333));
      scene.add(new THREE.AxesHelper(3));

      createPortal();

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.10;
      controls.minDistance = CAM.minDist;
      controls.maxDistance = CAM.maxDist;
      controls.minPolarAngle = CAM.minPolar;
      controls.maxPolarAngle = CAM.maxPolar;
      controls.minAzimuthAngle = CAM.minAzimuth;
      controls.maxAzimuthAngle = CAM.maxAzimuth;
      controls.enablePan = true;
      controls.screenSpacePanning = false;
      controls.panSpeed = 0.7;

      // AUDIO init
      initAudio();

      renderer.domElement.addEventListener("pointerdown", () => {
        followPlayer = true;
        startAudioOnce();
      });

      window.addEventListener("keydown", (e) => {
        startAudioOnce();

        const k = e.key.toLowerCase();

        if (k === "c" && playerRig) {
          const p = playerRig.position;
          controls.target.set(p.x, p.y + CAM.targetHeight, p.z);
          controls.update();
        }

        if (k === "e") extraKeys.e = true;
        if (e.code === "Space") extraKeys.space = true;

        if (k in keys) keys[k] = true;
      });

      window.addEventListener("keyup", (e) => {
        const k = e.key.toLowerCase();
        if (k === "e") extraKeys.e = false;
        if (e.code === "Space") extraKeys.space = false;

        if (k in keys) keys[k] = false;
      });

      clock = new THREE.Clock();
      window.addEventListener("resize", onResize);

      loadGLB();
      animate();
    }

    function update(dt){
      // freeze overlays
      if (gameWon || gameLost) {
        if (portalMat) portalMat.uniforms.time.value += dt;
        if (portalMesh) portalMesh.lookAt(camera.position);
        return;
      }

      // timer
      timeLeftMs -= dt * 1000;
      if (timeLeftMs <= 0) { loseByTime(); return; }

      // anim portal
      if (portalMat) portalMat.uniforms.time.value += dt;
      if (portalMesh) portalMesh.lookAt(camera.position);

      // kitsune / oni
      if (extraKeys.e) { extraKeys.e = false; useKitsune(); }
      if (extraKeys.space) shootFireball();

      // mixers
      if (playerMixer) playerMixer.update(dt);
      if (bossMixer) bossMixer.update(dt);

      // player move
      if (playerRig) {
        const speedBase = 3.8;
        const speed = powers.chane ? speedBase * 1.45 : speedBase;

        let x = 0, z = 0;
        if (keys.w) z -= 1;
        if (keys.s) z += 1;
        if (keys.a) x -= 1;
        if (keys.d) x += 1;

        const moving = (x !== 0 || z !== 0);

        if (!seen && moving) {
          const dir = new THREE.Vector3(x, 0, z).normalize();
          playerRig.position.addScaledVector(dir, speed * dt);
          playerRig.rotation.y = Math.atan2(dir.x, dir.z);
          playPlayer(playerAnims["run1"] ? "run1" : "idle1");
        } else {
          playPlayer("idle1");
        }

        if (obstacles.length) resolveCircleVsAABB(playerRig.position, PLAYER_RADIUS);

        if (followPlayer) {
          const p = playerRig.position;
          controls.target.lerp(new THREE.Vector3(p.x, p.y + CAM.targetHeight, p.z), 0.18);
        }
        clampTargetToPlayer();
      }

      updatePickups();
      updateProjectiles(dt);

      // boss patrol
      if (bossRig) {
        const before = bossRig.position.clone();
        updateBossPatrol(dt);
        const moved = before.distanceTo(bossRig.position) > 0.0005;
        if (moved && bossAnims["walk2"]) playBoss("walk2");
        else if (!moved && bossAnims["idle2"]) playBoss("idle2");
      }

      updateFOV();

      // win
      if (checkPortalWin()) {
        setStatus("üèÅ ¬°GANASTE! LOGRASTE ESCAPAR.");
        winGame();
        return;
      }

      // lose by detection
      if (!seen && isPlayerInFOV()) {
        seen = true;
        setStatus("üö® ¬°TE VIO! (tocaste el FOV rojo)");
        if (fovMesh) fovMesh.material.opacity = FOV.opacitySeen;
      } else if (!seen) {
        if (fovMesh) fovMesh.material.opacity = FOV.opacity;
      }

      // dialog follow
      updateSpeech();

      updateHUD();
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);
      update(dt);
      controls.update();
      renderer.render(scene, camera);
    }

    function onResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
  </script>
</body>
</html>
